# Gemini-chan Project Onboarding Summary

## Project Overview

This project is a sophisticated AI companion application built with Google's Gemini AI and Live2D technology. The application provides both text-based and voice-based conversational interfaces with a virtual character.

## Architecture Overview

The application follows a modular architecture with several key components:

1.  **App Core (`app/`)**: The main application entry point and UI orchestration.
2.  **Features (`features/`)**: Modular functionality like AI services, memory management, persona handling, summarization, and TTS.
3.  **Components (`components/`)**: Reusable UI elements like chat views, call transcripts, controls panels, etc.
4.  **Services (`services/`)**: Cross-cutting concerns like logging, energy management, and Live2D mapping.
5.  **Live2D (`live2d/`)**: All logic related to loading, rendering, and animating the Live2D model.
6.  **Store (`store/`)**: Data persistence layer, specifically the `VectorStore` for memory.
7.  **Visuals (`visuals/`)**: Advanced visual effects and 3D rendering components.
8.  **Shared (`shared/`)**: Common types and utilities used across the application.
9.  **Docs (`docs/`)**: Extensive documentation covering the project's design, stories, and technical details.

## Key Systems

### 1. AI Processing Pipeline (NPU-VPU)

The application uses a dual-stage AI processing pipeline:

*   **Neural Processing Unit (NPU) (`features/ai/NPUService.ts`)**:
    *   Analyzes user input and infers emotional states.
    *   Retrieves relevant memories from the `VectorStore` with emotion-biased re-ranking.
    *   Returns plain-text advisor context in a standardized format:
        *   USER_EMOTION: <emotion> (confidence=<0..1>)
        *   MODEL_EMOTION: <emotion> (confidence=<0..1>)
        *   ADVISOR_CONTEXT: bullet list of max 5 relevant facts (no user text included)
    *   Uses `gemini-2.5-flash` for analysis.
*   **Voice Processing Unit (VPU) (`features/vpu/VPUService.ts`)**:
    *   Handles real-time voice sessions (both text-to-speech and speech-to-speech).
    *   Connects to Google's Gemini Live API.
    *   Receives only advisor_context + raw user message (no emotion callbacks).
    *   Manages audio streaming, session resumption, and interruptions.
    *   Uses `gemini-2.0-flash-exp` or `gemini-2.0-flash-thinking-exp` depending on energy levels.

Data flows from the user through the NPU (for analysis and context enrichment) to the VPU (for generation and response).
The Intention Bridge now passes only advisor_context, with no JSON parsing in the live path.

### 2. Memory System (`features/memory/`)

*   **MemoryService (`MemoryService.ts`)**:
    *   Processes and stores conversation memories.
    *   Previously stored entire conversation chunks, but was updated to extract and store individual facts using `gemini-2.5-flash-lite`.
    *   Uses `extractAndStoreFacts` to parse conversation turns and store granular facts.
    *   Now uses advisor_context for AEI (Artificial Emotional Intelligence) biasing:
        *   Extracts USER_EMOTION from advisor context to bias fact extraction.
        *   Normalizes emotion labels to canonical set (joy, sadness, anger, fear, surprise, neutral, curiosity).
    *   Interfaces with the `VectorStore` for persistence.
*   **VectorStore (`store/VectorStore.ts`)**:
    *   Stores memories as vectors in `localStorage`.
    *   Performs semantic search using embeddings generated by `gemini-embedding-001`.
    *   Implements caching for search results to improve performance.
    *   Re-ranks memories using composite score: 0.6×similarity + 0.2×recency + 0.1×reinforcement + 0.1×emotionMatch.
    *   DEV_DEBUG=1 environment variable enables logging of re-ranking contributions for tuning.

### 3. Health Metrics and Memory Hygiene (`services/HealthMetricsService.ts`, enhanced `MemoryService.ts`)
*   **Health Metrics**: Tracks NPU latency, VPU start latency, and MPU turnaround times for performance monitoring.
*   **Memory Hygiene**: Implements time-decay for lower-confidence memories and pinning mechanism to preserve important facts.
*   **Periodic Maintenance**: Automatically applies memory decay every 10 minutes to keep the memory store clean and efficient.

### 4. Energy Management (`features/tts/TtsEnergyBar.ts`, `services/EnergyBarService.ts`)

*   Implements a dual-energy system for Text-to-Speech (TTS) and Speech-to-Speech (STS).
*   Energy levels decrease with usage and naturally replenish over time.
*   Different AI models are used based on current energy levels to manage quotas.
*   When energy is depleted, fallback mechanisms (like summarization) are triggered.

### 5. Persona System (`features/persona/PersonaManager.ts`)

*   Manages different character personas (e.g., "Assistant", "VTuber", "Sourceress").
*   Each persona has its own system prompt, energy level prompts, and potentially unique behaviors.

### 6. Live2D Integration (`live2d/`)

*   Loads and renders Live2D models.
*   Maps emotions and events to specific animations and motions.
*   Handles audio-reactive visualizations.

### 6. Health Metrics and Memory Hygiene (`services/HealthMetricsService.ts`, enhanced `MemoryService.ts`)
*   **Health Metrics**: Tracks NPU latency, VPU start latency, and MPU turnaround times for performance monitoring.
*   **Memory Hygiene**: Implements time-decay for lower-confidence memories and pinning mechanism to preserve important facts.
*   **Periodic Maintenance**: Automatically applies memory decay every 10 minutes to keep the memory store clean and efficient.

## Recent Changes and Fixes

1.  **Memory Amnesia Fix**:
    *   **Problem**: The `MemoryService` was storing large conversation chunks, making it difficult for the NPU to retrieve specific relevant information.
    *   **Solution**: Implemented `extractAndStoreFacts` in `MemoryService` to use `gemini-2.5-flash-lite` to parse conversation turns and store individual facts. Modified `app/main.tsx` to call this new method instead of the old `processAndStoreMemory` for raw context.
2.  **Lit Lifecycle Warnings**:
    *   **Problem**: Synchronous state updates in `firstUpdated` lifecycle methods in `app/main.tsx` and `live2d/live2d-visual.ts` were causing warnings.
    *   **Solution**: Adjusted the timing of initial greeting messages in `app/main.tsx` and made scroll state updates asynchronous in `components/ChatView.ts` and `components/CallTranscript.ts`.
3.  **AI Service Parser Removal**:
    *   **Problem**: Brittle JSON parsers in `BaseAIService` and `NPUService` were causing issues.
    *   **Solution**: Removed the parsers as the NPU now handles raw responses.
4.  **NPU Prompt Management**:
    *   **Problem**: NPU prompts were hardcoded in the service file.
    *   **Solution**: Moved prompts to markdown files in the `prompts/npu/` directory for better maintainability.
5.  **ESLint Configuration Issue**:
    *   **Problem**: ESLint was incorrectly flagging `NPUService` and `MemoryService` as unused variables in `features/vpu/VPUService.ts`.
    *   **Solution**: Analysis showed that these variables were not actually imported or used in `VPUService.ts`. The issue was likely a misconfiguration in the ESLint setup, not a problem with the code itself.

## File Structure Highlights

*   `app/main.tsx`: Main application logic, session management, UI event handling.
*   `features/ai/NPUService.ts`: Core logic for analyzing user input and preparing context for the VPU.
*   `features/vpu/VPUService.ts`: Core logic for managing real-time voice sessions with Gemini Live.
*   `features/memory/MemoryService.ts`: Logic for storing and retrieving conversation memories.
*   `store/VectorStore.ts`: Persistence layer for memories using localStorage and embeddings.
*   `live2d/live2d-visual.ts`: Integration point for Live2D model rendering and animation.
*   `components/ChatView.ts`: UI component for the text-based chat interface.
*   `components/CallTranscript.ts`: UI component for the voice call transcript.
*   `prompts/npu/combined-npu.prompt.md`: Markdown template for the NPU's prompt.

## Development Practices

*   Uses LitElement for building reactive web components.
*   Follows a four-phase agile development process (Analyst, Architect, Planner, Coder).
*   Employs TypeScript for type safety.
*   Uses Vite for development and building.
*   Implements Husky for git hooks to enforce code quality (ESLint, Prettier).